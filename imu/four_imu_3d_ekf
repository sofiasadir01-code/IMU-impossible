#!/usr/bin/env python3
"""
two_imu_planar_ekf.py

Planar EKF for two IMUs with lever-arm accelerometer difference constraints.

Assumptions:
- Rigid body, two IMUs mounted at known relative position r21_B (body frame).
- Planar motion: x,y translation and yaw rotation (about body/world z axis).
- Uses only:
    - Gyro z from IMU1 and IMU2 (to estimate yaw rate r and each gyro bias)
    - Differenced accelerometer (IMU2 aligned into IMU1 axes) for x/y channels
      to constrain yaw dynamics and estimate accel bias difference between IMUs.

Key limitation:
- Without external aiding, absolute x,y will drift. EKF includes x,y,vx,vy but
  they are not observable with IMUs alone.

Dependencies:
- numpy

Hardware interface:
- Provide your own read_imu1(), read_imu2() functions that return:
    accel (3,), gyro (3,) in consistent units.
"""

from __future__ import annotations
import time
import numpy as np
from dataclasses import dataclass

# -----------------------------
# Utility: noise stats from still data
# -----------------------------

def std_zero_mean(samples: np.ndarray) -> np.ndarray:
    """
    samples: shape (N,) or (N,3)
    returns per-axis sample standard deviation after subtracting mean.
    """
    s = np.asarray(samples, dtype=float)
    s0 = s - np.mean(s, axis=0, keepdims=True)
    return np.std(s0, axis=0, ddof=1)

# -----------------------------
# EKF definitions
# -----------------------------

@dataclass
class EKFConfig:
    # Lever arm from IMU1 to IMU2 expressed in IMU1/body axes (meters)
    r21_B: np.ndarray  # shape (3,)

    # Alignment matrix mapping IMU2 sensor axes into IMU1 axes: z2_in_1 = C21 @ z2
    C21: np.ndarray  # shape (3,3)

    # Process noise variances (tune)
    q_v: float          # (m/s^2)^2 per step proxy on velocity random walk
    q_r: float          # (rad/s^2)^2 per step proxy on yaw rate random walk
    q_bg: float         # (rad/s)^2 per step on gyro bias random walk
    q_dbax: float       # (m/s^2)^2 per step on delta accel bias x random walk
    q_dbay: float       # (m/s^2)^2 per step on delta accel bias y random walk

    # Measurement noise variances (from still-std)
    r_g1: float         # variance of gyro z measurement IMU1 (rad/s)^2
    r_g2: float         # variance of gyro z measurement IMU2 (rad/s)^2
    r_dax: float        # variance of delta accel x measurement (m/s^2)^2
    r_day: float        # variance of delta accel y measurement (m/s^2)^2


class TwoIMUPlanarEKF:
    """
    State vector:
      x = [ xW, yW, vxW, vyW, psi, r, bg1, bg2, dbax, dbay ]^T

    Measurements:
      z = [ gz1, gz2, d_ax, d_ay ]^T
    where:
      gz1 = gyro1_z
      gz2 = gyro2_z (aligned if needed; here we assume gyro axes already close,
            but you can also align full gyro with C21 and take z)
      d_a = accel2_aligned - accel1 (in IMU1 axes)

    Measurement model:
      gz1 = r + bg1 + n
      gz2 = r + bg2 + n

      d_ax = - rdot * y2 - r^2 * x2 + dbax + n
      d_ay = + rdot * x2 - r^2 * y2 + dbay + n

    rdot is approximated numerically from successive r estimates:
      rdot ≈ (r_pred - r_prev_est) / dt
    """

    def __init__(self, cfg: EKFConfig):
        self.cfg = cfg
        self.n = 10  # state dimension
        self.m = 4   # measurement dimension

        # Initialize state and covariance
        self.x = np.zeros((self.n, 1), dtype=float)

        # Large initial uncertainty on position/velocity; moderate on angles/biases
        P0 = np.diag([
            10.0**2, 10.0**2,   # x,y (m^2)
            1.0**2,  1.0**2,    # vx,vy ((m/s)^2)
            (np.deg2rad(30))**2,# psi (rad^2)
            (np.deg2rad(30))**2,# r (rad/s)^2
            (np.deg2rad(5))**2, # bg1
            (np.deg2rad(5))**2, # bg2
            (0.5)**2,           # dbax (m/s^2)^2
            (0.5)**2,           # dbay
        ])
        self.P = P0

        # For rdot approximation
        self._r_prev = 0.0

    # -------------------------
    # Process model: predict
    # -------------------------

    def predict(self, dt: float):
        dt = float(dt)
        if dt <= 0:
            return

        x = self.x

        # Unpack
        xW, yW, vxW, vyW, psi, r, bg1, bg2, dbax, dbay = x.flatten()

        # Simple kinematics
        xW_new = xW + vxW * dt
        yW_new = yW + vyW * dt
        vxW_new = vxW
        vyW_new = vyW

        psi_new = psi + r * dt
        r_new = r

        # Bias random walks: remain same in mean
        bg1_new = bg1
        bg2_new = bg2
        dbax_new = dbax
        dbay_new = dbay

        self.x = np.array([[xW_new, yW_new, vxW_new, vyW_new,
                            psi_new, r_new, bg1_new, bg2_new, dbax_new, dbay_new]]).T

        # Jacobian F = ∂f/∂x
        F = np.eye(self.n)
        F[0, 2] = dt  # x depends on vx
        F[1, 3] = dt  # y depends on vy
        F[4, 5] = dt  # psi depends on r

        # Process noise Q (discrete, simple diagonal)
        # These are tuning knobs, not derived from physics here.
        Q = np.zeros((self.n, self.n))
        Q[2, 2] = self.cfg.q_v * dt**2   # vx random walk proxy
        Q[3, 3] = self.cfg.q_v * dt**2   # vy
        Q[5, 5] = self.cfg.q_r * dt**2   # r random walk proxy
        Q[6, 6] = self.cfg.q_bg * dt     # bg1 random walk
        Q[7, 7] = self.cfg.q_bg * dt     # bg2
        Q[8, 8] = self.cfg.q_dbax * dt   # delta accel bias x
        Q[9, 9] = self.cfg.q_dbay * dt   # delta accel bias y

        self.P = F @ self.P @ F.T + Q

    # -------------------------
    # Measurement model + EKF update
    # -------------------------

    def update(self, z: np.ndarray, dt: float):
        """
        z shape (4,) or (4,1):
          [gz1, gz2, d_ax, d_ay]
        """
        z = np.asarray(z, dtype=float).reshape((self.m, 1))
        dt = float(dt)
        if dt <= 0:
            return

        # Current predicted state
        x = self.x.flatten()
        r = x[5]
        bg1 = x[6]
        bg2 = x[7]
        dbax = x[8]
        dbay = x[9]

        # Lever arm components (IMU2 position relative to IMU1 in IMU1/body axes)
        x2 = float(self.cfg.r21_B[0])
        y2 = float(self.cfg.r21_B[1])

        # Approximate rdot from successive r estimates
        # Use predicted r vs last posterior r.
        rdot = (r - self._r_prev) / dt

        # Predicted measurement h(x)
        # gyro z
        zhat_g1 = r + bg1
        zhat_g2 = r + bg2

        # delta accel (planar rigid-body rotational terms)
        zhat_dax = - rdot * y2 - (r**2) * x2 + dbax
        zhat_day = + rdot * x2 - (r**2) * y2 + dbay

        zhat = np.array([[zhat_g1, zhat_g2, zhat_dax, zhat_day]]).T

        # Measurement Jacobian H = ∂h/∂x (4x10)
        H = np.zeros((self.m, self.n))

        # Row 0: gz1 = r + bg1
        H[0, 5] = 1.0
        H[0, 6] = 1.0

        # Row 1: gz2 = r + bg2
        H[1, 5] = 1.0
        H[1, 7] = 1.0

        # Rows 2-3: dax, day
        # zhat_dax = -((r - r_prev)/dt)*y2 - r^2*x2 + dbax
        # derivative w.r.t r (treat r_prev as constant):
        # d/dr [-(r-r_prev)/dt*y2 - r^2*x2] = -(1/dt)*y2 - 2r*x2
        H[2, 5] = -(1.0/dt) * y2 - 2.0 * r * x2
        H[2, 8] = 1.0  # dbax

        # zhat_day = +((r - r_prev)/dt)*x2 - r^2*y2 + dbay
        # d/dr = +(1/dt)*x2 - 2r*y2
        H[3, 5] = +(1.0/dt) * x2 - 2.0 * r * y2
        H[3, 9] = 1.0  # dbay

        # Measurement noise covariance R
        R = np.diag([self.cfg.r_g1, self.cfg.r_g2, self.cfg.r_dax, self.cfg.r_day])

        # EKF update
        y = z - zhat
        S = H @ self.P @ H.T + R
        K = self.P @ H.T @ np.linalg.inv(S)

        self.x = self.x + K @ y
        I = np.eye(self.n)
        self.P = (I - K @ H) @ self.P

        # Store posterior r for next rdot approximation
        self._r_prev = float(self.x[5, 0])

    # -------------------------
    # Helpers
    # -------------------------

    def get_state(self) -> dict:
        x = self.x.flatten()
        return {
            "xW": float(x[0]),
            "yW": float(x[1]),
            "vxW": float(x[2]),
            "vyW": float(x[3]),
            "psi_deg": float(np.rad2deg(x[4])),
            "r_deg_s": float(np.rad2deg(x[5])),
            "bg1_deg_s": float(np.rad2deg(x[6])),
            "bg2_deg_s": float(np.rad2deg(x[7])),
            "dbax": float(x[8]),
            "dbay": float(x[9]),
        }


# -----------------------------
# Hardware interface (YOU replace these)
# -----------------------------

def read_imu1() -> tuple[np.ndarray, np.ndarray]:
    """
    Return (accel, gyro) for IMU1 in IMU1 axes.
    accel in m/s^2, gyro in rad/s.
    """
    raise NotImplementedError("Implement read_imu1() for your hardware.")

def read_imu2() -> tuple[np.ndarray, np.ndarray]:
    """
    Return (accel, gyro) for IMU2 in IMU2 axes.
    accel in m/s^2, gyro in rad/s.
    """
    raise NotImplementedError("Implement read_imu2() for your hardware.")


# -----------------------------
# Optional: Still-data noise estimation
# -----------------------------

def collect_still_data(seconds: float = 60.0, hz: float = 100.0):
    """
    Collect still data from both IMUs for noise estimates.
    Returns dict with arrays.
    """
    dt = 1.0 / hz
    N = int(seconds * hz)

    a1 = np.zeros((N, 3))
    g1 = np.zeros((N, 3))
    a2 = np.zeros((N, 3))
    g2 = np.zeros((N, 3))

    for k in range(N):
        acc1, gyr1 = read_imu1()
        acc2, gyr2 = read_imu2()
        a1[k, :] = acc1
        g1[k, :] = gyr1
        a2[k, :] = acc2
        g2[k, :] = gyr2
        time.sleep(dt)

    return {"a1": a1, "g1": g1, "a2": a2, "g2": g2}


def estimate_R_from_still(still: dict, C21: np.ndarray) -> dict:
    """
    Compute std and variances for:
      gyro z noise each IMU,
      delta accel x/y noise after alignment.

    Returns variances: r_g1, r_g2, r_dax, r_day.
    """
    a1 = still["a1"]
    g1 = still["g1"]
    a2 = still["a2"]
    g2 = still["g2"]

    # Gyro z std (zero-mean) -> variance
    sigma_g1z = float(std_zero_mean(g1[:, 2]) )
    sigma_g2z = float(std_zero_mean(g2[:, 2]) )

    # Align accel2 into IMU1 axes, then difference
    a2_in_1 = (C21 @ a2.T).T  # (N,3)
    da = a2_in_1 - a1
    sigma_dax = float(std_zero_mean(da[:, 0]))
    sigma_day = float(std_zero_mean(da[:, 1]))

    return {
        "r_g1": sigma_g1z**2,
        "r_g2": sigma_g2z**2,
        "r_dax": sigma_dax**2,
        "r_day": sigma_day**2,
        "sigma_g1z": sigma_g1z,
        "sigma_g2z": sigma_g2z,
        "sigma_dax": sigma_dax,
        "sigma_day": sigma_day,
    }


# -----------------------------
# Main loop
# -----------------------------

def main():
    # Known lever arm (meters)
    r21_B = np.array([0.08, 0.08, 0.01], dtype=float)

    # Alignment matrix: start with identity unless you calibrated
    C21 = np.eye(3)

    # Example placeholder noise values (MUST be replaced from still-data logs)
    # These numbers are not "universal"; they depend on your units and sensor settings.
    r_g1 = (np.deg2rad(0.2))**2      # (rad/s)^2
    r_g2 = (np.deg2rad(0.2))**2
    r_dax = (0.15)**2                # (m/s^2)^2
    r_day = (0.15)**2

    # Example process noise tuning (start small, then tune)
    cfg = EKFConfig(
        r21_B=r21_B,
        C21=C21,
        q_v=0.5**2,                   # allow velocity to wander (placeholder)
        q_r=(np.deg2rad(30.0))**2,     # allow r to change (placeholder)
        q_bg=(np.deg2rad(0.02))**2,    # gyro bias drift (placeholder)
        q_dbax=(0.02)**2,             # delta accel bias drift (placeholder)
        q_dbay=(0.02)**2,
        r_g1=r_g1,
        r_g2=r_g2,
        r_dax=r_dax,
        r_day=r_day,
    )

    ekf = TwoIMUPlanarEKF(cfg)

    print("Two-IMU planar EKF starting...")
    print("State: x,y,vx,vy,psi,r,bg1,bg2,dbax,dbay")
    print("Measurements: gz1,gz2,delta_ax,delta_ay")
    print()

    t_prev = time.time()

    while True:
        t_now = time.time()
        dt = max(1e-3, t_now - t_prev)
        t_prev = t_now

        # Read both IMUs
        acc1, gyr1 = read_imu1()
        acc2, gyr2 = read_imu2()

        # Align IMU2 accel into IMU1 axes
        acc2_in_1 = cfg.C21 @ acc2

        # Build measurement z
        gz1 = float(gyr1[2])
        gz2 = float(gyr2[2])  # if IMU2 axes differ, align gyro too: gz2 = (C21 @ gyr2)[2]
        da = acc2_in_1 - acc1
        dax = float(da[0])
        day = float(da[1])

        z = np.array([gz1, gz2, dax, day], dtype=float)

        # EKF steps
        ekf.predict(dt)
        ekf.update(z, dt)

        s = ekf.get_state()
        print(
            f"dt={dt:0.3f} | "
            f"psi={s['psi_deg']:8.2f} deg | r={s['r_deg_s']:8.2f} deg/s | "
            f"bg1={s['bg1_deg_s']:7.3f} bg2={s['bg2_deg_s']:7.3f} | "
            f"dbax={s['dbax']:7.3f} dbay={s['dbay']:7.3f}"
        )

        time.sleep(0.01)


if __name__ == "__main__":
    main()
